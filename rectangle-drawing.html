<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rectangle Drawing Export</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            border: none;
            cursor: crosshair;
            background-color: #1e1e1e;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .tooltip {
            position: absolute;
            background: #252526;
            border: 1px solid #454545;
            border-radius: 3px;
            padding: 8px 12px;
            color: #cccccc;
            font-size: 12px;
            z-index: 1500;
            max-width: 300px;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="tooltip" class="tooltip"></div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Grid and zoom settings
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        const gridSize = 10;
        
        // Data
        let rectangles = [];
        let connections = [];
        
        // Classes
        class Rectangle {
            constructor(x, y, width, height, name = '', description = '', payload = '', color = '#ffffff') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.selected = false;
                this.id = Math.random().toString(36).substr(2, 9);
                this.name = name;
                this.description = description;
                this.payload = payload;
                this.color = color;
            }
            
            contains(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }
        
        class Connection {
            constructor(fromRect, fromPoint, toRect, toPoint, label = '', description = '', payload = '', color = '#4ecdc4', lineStyle = 'solid') {
                this.fromRect = fromRect;
                this.fromPoint = fromPoint;
                this.toRect = toRect;
                this.toPoint = toPoint;
                this.id = Math.random().toString(36).substr(2, 9);
                this.selected = false;
                this.label = label;
                this.description = description;
                this.payload = payload;
                this.color = color;
                this.lineStyle = lineStyle;
                this.labelPosition = null;
            }
            
            getConnectionPoints() {
                const fromEdge = { x: this.fromRect.x + this.fromRect.width, y: this.fromRect.y + this.fromRect.height / 2 };
                const toEdge = { x: this.toRect.x, y: this.toRect.y + this.toRect.height / 2 };
                return { from: fromEdge, to: toEdge };
            }
            
            isNearConnection(x, y, tolerance = 8) {
                const points = this.getConnectionPoints();
                for (let t = 0; t <= 1; t += 0.05) {
                    const curvePoint = getBezierPoint(points.from.x, points.from.y, points.to.x, points.to.y, t);
                    const distance = Math.sqrt((x - curvePoint.x) ** 2 + (y - curvePoint.y) ** 2);
                    if (distance <= tolerance / zoom) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        function getBezierPoint(fromX, fromY, toX, toY, t) {
            const distance = Math.abs(toX - fromX);
            const curveOffset = Math.min(distance * 0.5, 80);
            const cp1X = fromX + curveOffset;
            const cp1Y = fromY;
            const cp2X = toX - curveOffset;
            const cp2Y = toY;
            
            const t1 = 1 - t;
            const t12 = t1 * t1;
            const t13 = t12 * t1;
            const t2 = t * t;
            const t3 = t2 * t;
            
            return {
                x: t13 * fromX + 3 * t12 * t * cp1X + 3 * t1 * t2 * cp2X + t3 * toX,
                y: t13 * fromY + 3 * t12 * t * cp1Y + 3 * t1 * t2 * cp2Y + t3 * toY
            };
        }
        
        function drawGrid() {
            ctx.save();
            ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
            
            // Calculate visible area in world coordinates
            const startX = Math.floor((-panX) / zoom / gridSize) * gridSize;
            const startY = Math.floor((-panY) / zoom / gridSize) * gridSize;
            const endX = Math.ceil((canvas.width - panX) / zoom / gridSize) * gridSize;
            const endY = Math.ceil((canvas.height - panY) / zoom / gridSize) * gridSize;
            
            // Set dot style - subtle gray dots
            ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';
            const dotRadius = 1 / zoom; // Very small dots that scale with zoom
            
            // Draw dots at each grid intersection
            for (let x = startX; x <= endX; x += gridSize) {
                for (let y = startY; y <= endY; y += gridSize) {
                    ctx.beginPath();
                    ctx.arc(x, y, dotRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawCurvedConnection(fromX, fromY, toX, toY, connection = null) {
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            
            const distance = Math.abs(toX - fromX);
            const curveOffset = Math.min(distance * 0.5, 80);
            const cp1X = fromX + curveOffset;
            const cp1Y = fromY;
            const cp2X = toX - curveOffset;
            const cp2Y = toY;
            
            ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, toX, toY);
            ctx.stroke();
        }
        
        function drawConnectionDot(x, y) {
            ctx.fillStyle = '#4ecdc4';
            const radius = 4 / zoom;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        function drawRectangleText(rectangle) {
            if (!rectangle.name) return;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = (12 / zoom) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = rectangle.x + rectangle.width / 2;
            const centerY = rectangle.y + rectangle.height / 2;
            
            ctx.fillText(rectangle.name, centerX, centerY);
        }
        
        function drawConnectionLabel(connection) {
            if (!connection.label) return;
            
            const points = connection.getConnectionPoints();
            let labelPos;
            
            if (connection.labelPosition) {
                labelPos = connection.labelPosition;
            } else {
                labelPos = getBezierPoint(points.from.x, points.from.y, points.to.x, points.to.y, 0.5);
            }
            
            ctx.fillStyle = '#4ecdc4';
            ctx.font = (10 / zoom) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const textWidth = ctx.measureText(connection.label).width + 8 / zoom;
            const textHeight = 16 / zoom;
            
            ctx.fillRect(labelPos.x - textWidth/2, labelPos.y - textHeight/2, textWidth, textHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillText(connection.label, labelPos.x, labelPos.y);
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            
            ctx.save();
            ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
            
            // Draw connections
            connections.forEach(conn => {
                const points = conn.getConnectionPoints();
                const fromPoint = points.from;
                const toPoint = points.to;
                
                ctx.strokeStyle = conn.color || '#4ecdc4';
                ctx.lineWidth = 2 / zoom;
                
                // Set line style
                const lineStyle = conn.lineStyle || 'solid';
                if (lineStyle === 'thick-dotted') {
                    ctx.setLineDash([8 / zoom, 8 / zoom]); // Thick dotted line
                    ctx.lineWidth = 4 / zoom; // Make it thicker
                } else if (lineStyle === 'dashed') {
                    ctx.setLineDash([15 / zoom, 10 / zoom]); // Dashed line
                } else {
                    ctx.setLineDash([]); // Solid line
                }
                
                drawCurvedConnection(fromPoint.x, fromPoint.y, toPoint.x, toPoint.y, conn);
                
                // Reset line dash and width
                ctx.setLineDash([]);
                ctx.lineWidth = conn.selected ? 3 / zoom : 2 / zoom;
                
                drawConnectionDot(fromPoint.x, fromPoint.y);
                drawConnectionDot(toPoint.x, toPoint.y);
                
                if (conn.label && conn.label.trim() !== '') {
                    drawConnectionLabel(conn);
                }
            });
            
            // Draw rectangles
            rectangles.forEach(rectangle => {
                const hasLeftConnections = connections.some(c => c.toRect === rectangle);
                const hasRightConnections = connections.some(c => c.fromRect === rectangle);
                
                // Convert hex color to rgba with low opacity for subtle background
                let fillColor = 'rgba(255, 255, 255, 0.1)'; // Default white
                if (rectangle.color && rectangle.color !== '#ffffff') {
                    const hexColor = rectangle.color;
                    const r = parseInt(hexColor.substr(1, 2), 16);
                    const g = parseInt(hexColor.substr(3, 2), 16);
                    const b = parseInt(hexColor.substr(5, 2), 16);
                    fillColor = 'rgba(' + r + ', ' + g + ', ' + b + ', 0.15)'; // Subtle 15% opacity
                }
                
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = '#ffffff';
                
                ctx.fillRect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
                
                if (hasLeftConnections || hasRightConnections) {
                    const normalWidth = 1 / zoom;
                    const thickWidth = 5 / zoom;
                    
                    // Left edge
                    ctx.lineWidth = hasLeftConnections ? thickWidth : normalWidth;
                    ctx.beginPath();
                    ctx.moveTo(rectangle.x, rectangle.y);
                    ctx.lineTo(rectangle.x, rectangle.y + rectangle.height);
                    ctx.stroke();
                    
                    // Right edge
                    ctx.lineWidth = hasRightConnections ? thickWidth : normalWidth;
                    ctx.beginPath();
                    ctx.moveTo(rectangle.x + rectangle.width, rectangle.y);
                    ctx.lineTo(rectangle.x + rectangle.width, rectangle.y + rectangle.height);
                    ctx.stroke();
                    
                    // Top and bottom edges
                    ctx.lineWidth = normalWidth;
                    ctx.beginPath();
                    ctx.moveTo(rectangle.x, rectangle.y);
                    ctx.lineTo(rectangle.x + rectangle.width, rectangle.y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(rectangle.x, rectangle.y + rectangle.height);
                    ctx.lineTo(rectangle.x + rectangle.width, rectangle.y + rectangle.height);
                    ctx.stroke();
                } else {
                    ctx.lineWidth = 1 / zoom;
                    ctx.strokeRect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
                }
                
                if (rectangle.name && rectangle.name.trim() !== '') {
                    drawRectangleText(rectangle);
                }
            });
            
            ctx.restore();
        }
        
        // Mouse handling for tooltips
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const x = (screenX - panX) / zoom;
            const y = (screenY - panY) / zoom;
            
            const tooltip = document.getElementById('tooltip');
            const hoveredRect = rectangles.find(r => r.contains(x, y));
            
            if (hoveredRect && hoveredRect.description && hoveredRect.description.trim() !== '') {
                tooltip.textContent = hoveredRect.description;
                tooltip.style.display = 'block';
                tooltip.style.left = (screenX + 15) + 'px';
                tooltip.style.top = screenY + 'px';
            } else {
                const hoveredConnection = connections.find(c => c.isNearConnection(x, y));
                if (hoveredConnection && hoveredConnection.description && hoveredConnection.description.trim() !== '') {
                    tooltip.textContent = hoveredConnection.description;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (screenX + 15) + 'px';
                    tooltip.style.top = screenY + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }
        });
        
        // Load data and initialize
        rectangles = [{"x":110,"y":50,"width":110,"height":60,"id":"giogrll4k","name":"A","description":"Alpha","payload":"AAA\n","color":"#d62424"},{"x":290,"y":170,"width":110,"height":60,"id":"kloyyjtrh","name":"B","description":"Bravo","payload":"BBB\n","color":"#0bad0e"},{"x":520,"y":140,"width":110,"height":60,"id":"bkf1chd45","name":"C","description":"Charlie","payload":"CCCC\n","color":"#ffffff"},{"x":680,"y":90,"width":110,"height":60,"id":"5lplcdkth","name":"D","description":"Delta","payload":"DDDD\n---eof---\n","color":"#ffffff"}].map(r => {
            const rect = new Rectangle(r.x, r.y, r.width, r.height, r.name, r.description, r.payload, r.color);
            rect.id = r.id; // Preserve original ID
            return rect;
        });
        
        console.log('Loaded rectangles:', rectangles);
        
        // Load connections
        const connectionData = [{"fromRectId":"giogrll4k","toRectId":"kloyyjtrh","id":"je3i44li4","label":"AB","description":"A to B","payload":"a->B\n","color":"#8c4ccd","lineStyle":"solid","labelPosition":null},{"fromRectId":"kloyyjtrh","toRectId":"bkf1chd45","id":"1ea79jd1z","label":"BC","description":"b to c","payload":"B ----> C\n","color":"#4ecdc4","lineStyle":"dashed","labelPosition":null},{"fromRectId":"bkf1chd45","toRectId":"5lplcdkth","id":"a3j2gpx3e","label":"CD","description":"C to D","payload":"C --> D\n","color":"#4ecdc4","lineStyle":"solid","labelPosition":null},{"fromRectId":"giogrll4k","toRectId":"bkf1chd45","id":"nh1qjstv2","label":"Bypass","description":"","payload":"","color":"#4ecdc4","lineStyle":"thick-dotted","labelPosition":null}];
        console.log('Loading connections:', connectionData);
        
        connectionData.forEach(conn => {
            const fromRect = rectangles.find(r => r.id === conn.fromRectId);
            const toRect = rectangles.find(r => r.id === conn.toRectId);
            console.log('Connection:', conn, 'fromRect:', fromRect, 'toRect:', toRect);
            if (fromRect && toRect) {
                const fromPoint = { x: fromRect.x + fromRect.width, y: fromRect.y + fromRect.height / 2 };
                const toPoint = { x: toRect.x, y: toRect.y + toRect.height / 2 };
                const connection = new Connection(fromRect, fromPoint, toRect, toPoint, conn.label, conn.description, conn.payload, conn.color, conn.lineStyle);
                connection.id = conn.id;
                if (conn.labelPosition) {
                    connection.labelPosition = conn.labelPosition;
                }
                connections.push(connection);
                console.log('Added connection:', connection);
            }
        });
        
        console.log('Final connections array:', connections);
        
        // Initialize
        resizeCanvas();
    </script>
</body>
</html>